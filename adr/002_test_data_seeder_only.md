# ADR-002: テストデータ作成手法 - Seeder経由でのFactory使用

## 概要

テストデータ作成において、テストコード内でのFactory直接使用を禁止し、Seeder経由でのみFactoryを使用する方針を採用する。

## 課題

1. **テストの複雑化**: 大規模アプリケーションではFactoryがテストメソッドごとに必要となり、管理が複雑化する
2. **データ一貫性**: テストメソッド間でのデータ状態の予測が困難になる
3. **保守性**: テストコード内でのFactory直接使用により、関係性の管理が複雑になる

## 決定事項

**Seeder経由でのFactoryのみ使用**し、テストコード内でのFactory直接使用は禁止する。

## ステータス

Accepted

## 詳細

### 前提

- Laravel 12を使用したテスト環境
- PHPUnitによるFeature/Unitテスト
- 小規模から大規模への将来的な拡張を想定

### 制約

- テスト実行時間の最適化が必要
- テストデータの準備・クリーンアップが自動化されている必要
- 既存のLaravelテスト機能との互換性が必要

### 検討した選択肢

#### 選択肢1: Seeder経由でのFactory使用（採用）

**利点:**
- 統一的なテストデータ管理: 全テストで一貫したデータセットを使用
- 関係性の明確化: モデル間の関係が予測可能
- 保守性の向上: データ作成ロジックが集中管理される
- スケーラビリティ: 大規模アプリでも管理が容易
- 一貫性: テストデータ作成方針が統一される
- Factory活用: Seeder内でFactoryを使用してデータ作成の効率化

**欠点:**
- 初期設定の複雑さ: 包括的なSeederの作成が必要
- テスト分離の制約: 特定のテストケース向けのデータ作成が制限的

#### 選択肢2: Factory主体（見送り）

**利点:**
- 柔軟性: テストケースごとに最適化されたデータ作成
- 簡単な初期実装: 個別のFactoryは作成が容易
- Laravel標準: Laravelの推奨パターンに従う

**欠点:**
- 複雑化リスク: テストメソッド数に比例してFactory管理が複雑化
- データ関係の不明確性: テスト間でのデータ状態が予測困難
- 保守性の悪化: Factoryの数が増加すると関係性管理が困難

#### 選択肢3: 混在アプローチ（見送り）

**利点:**
- 状況に応じた最適化: 用途に応じてSeeder/Factoryを使い分け

**欠点:**
- 一貫性の欠如: テストデータ作成方針が不統一
- 学習コストの増加: 開発者が両方の手法を理解する必要
- 複雑性の増加: どちらを使うべきかの判断が必要

### 採用理由

1. **将来性**: 小規模アプリでは問題ないが、大規模化への対応を考慮
2. **保守性**: データ作成ロジックの集中管理により、変更時の影響範囲が明確
3. **一貫性**: 全テストで同じデータセットを使用することで、テスト結果の予測性が向上
4. **チーム開発**: 統一的なテストデータ管理により、チームメンバー間の理解が容易
5. **シンプル性**: 一つの手法に統一することで、開発者の認知負荷を軽減

### 実装指針

- `database/seeders/`ディレクトリでテストデータ用Seederを管理
- `RefreshDatabase`トレイトと組み合わせてテストごとにクリーンな状態を保証
- FactoryはSeeder内でのみ使用し、テストコード内での直接使用は禁止
- Seederは階層化して管理し、依存関係を明確にする
- テスト環境用の専用Seederを作成し、本番環境との明確な分離を行う
- テストクラスではSeederを呼び出してテストデータを準備する

### 実運用での学習事項（2025年6月追記）

#### テストデータ保証メソッドの導入

実際の運用で、ランダム性のあるSeederとテストの安定性確保の両立が課題となった。解決策として以下のパターンを採用：

**課題:**
- Seederで`rand(0, 5)`のようなランダム生成を使用すると、必要なテストデータが存在しない場合がある
- テスト内でのFactory使用を避けつつ、テスト実行に必要な最低限のデータを保証する必要

**解決策:**
```php
// CreatesScratches trait内
protected function ensureAtLeastOneThreadHasScratches(): void
{
    // テスト用：スクラッチを持つスレッドが最低1つ存在することを保証
    $threadsWithoutScratches = Thread::doesntHave('scratches')->get();
    
    if ($threadsWithoutScratches->isNotEmpty()) {
        $firstThreadWithoutScratches = $threadsWithoutScratches->first();
        $this->createScratches($firstThreadWithoutScratches, 1);
    }
}
```

**設計原則:**
1. **意図明確なメソッド名**: テスト用データ保証の目的を明確に表現
2. **最小限介入**: 既存のランダム性を尊重し、必要最小限のデータのみ保証
3. **ビジネス現実性**: データがない状態も正常な業務状態として残存
4. **責任の集約**: テストデータの複雑性をSeederが引き受け、テストコードは簡潔に保つ

**メリット:**
- **テスト安定性**: ランダムSeederでもテストが確実に実行可能
- **ルール維持**: Factory使用制限を維持しつつ問題解決
- **保守性**: テストデータ保証ロジックがSeeder内に集約
- **スケーラビリティ**: 30テーブル以上の大規模アプリでも適用可能

この経験により、Seeder-Onlyアプローチの有効性と実用性が実証された。
